{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Usage","text":"<p>This library takes in a task (like face localization) and computes activations for the data and computes the top percent of activations and can compute the model with those activations ablated.</p> <p>A task is just a Pandas dataframe with two required columns and one optional:</p> <ul> <li><code>data</code>: contains the data or path to the data (you define how to fetch data in <code>model_forward</code> later on).</li> <li><code>positive</code>: True or False. True when part of positive stimuli (ie faces). False when part of negative control stimuli (ie objects in the face localizer case).</li> <li>Optional <code>validation</code>: True or False. False means part of localization training. True means part of unseen validation that can be used later on to test the performance.</li> </ul> <p>See <code>face_data_viewer.ipynb</code> to view an example task.</p> <p>Next see how to operate on the task to localize your model below!</p>"},{"location":"#install","title":"Install","text":"<pre><code>pip install deeplocalizer\n</code></pre> <p>or </p> <pre><code>uv add deeplocalizer\n</code></pre> <p>Import</p> <pre><code>from deeplocalizer import DeepLocalizer # or import other functions in API below\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>An example using all of the core and visualization functions, see the face localization on Resnet example:  <code>resnet34_example.ipynb</code>.</p>"},{"location":"#api","title":"API","text":""},{"location":"#core","title":"Core","text":""},{"location":"#deeplocalizer.load_task","title":"load_task","text":"<pre><code>load_task(filename: str) -&gt; tuple[pd.DataFrame, pd.DataFrame] | pd.DataFrame\n</code></pre> <p>Loads in the task from a .parquet file (dataframe) with the columns <code>data</code> and <code>positive</code> and optionally <code>validation</code></p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>where the task is located as a .parquet file. Underlying file must be parquet</p> required <p>Returns:</p> Type Description <code>tuple[pd.DataFrame, pd.DataFrame] | pd.DataFrame</code> <p>If no <code>validation</code> column, just returns the dataframe. If there is a validation column splits the return into (task, validation).</p> Source code in <code>deeplocalizer/deeplocalizer.py</code> <pre><code>def load_task(filename: str) -&gt; tuple[pd.DataFrame, pd.DataFrame] | pd.DataFrame:\n    \"\"\"Loads in the task from a .parquet file (dataframe) with the columns `data` and `positive` and optionally `validation`\n\n    Parameters:\n        filename: where the task is located as a .parquet file. Underlying file must be parquet\n\n    Returns:\n        If no `validation` column, just returns the dataframe. If there is a validation column splits the return into (task, validation).\n    \"\"\"\n    assert os.path.exists(filename), \"task file must exist\"\n\n    df = pd.read_parquet(filename)\n    assert_is_task(df)\n\n    if \"validation\" in df.columns:\n        task = df[df[\"validation\"] == False]\n        validation = df[df[\"validation\"] == True]\n        return task, validation\n    else:\n        return df\n</code></pre>"},{"location":"#deeplocalizer.DeepLocalizer","title":"DeepLocalizer","text":"<pre><code>DeepLocalizer(task: pd.DataFrame, layers_activations: list[torch.nn.Module], model_forward: ModelForwardFunc, save_activations_func: SaveActivationsFunc = default_save_activations, ablate_activations_func: AblateActivationsFunc = default_flat_idxs_ablate, ablate_factor: float = 0.0, batch_size: int = 32)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>pd.DataFrame</code> <p>Pandas Dataframe with columns <code>data</code> and <code>positive</code> (bool).</p> required <code>layers_activations</code> <code>list[torch.nn.Module]</code> <p>list of torch modules/layers that we take activations from the outputs of.</p> required <code>model_forward</code> <code>ModelForwardFunc</code> <p>callback that given a list of data, runs model inference. Can return single output or tuple of outputs from here.</p> required <code>save_activations_func</code> <code>SaveActivationsFunc</code> <p>defines how to save activations from each of the layer_activations. By default just saves the entire output.</p> <code>default_save_activations</code> <code>ablate_activations_func</code> <code>AblateActivationsFunc</code> <p>defines how to ablate the activations from each of the layer_activations. By default ablates based on the flattened index.</p> <code>default_flat_idxs_ablate</code> <code>ablate_factor</code> <code>float</code> <p>what to multiply the values to be ablated. Defaults to 0 (full ablation).</p> <code>0.0</code> <code>batch_size</code> <code>int</code> <p>Defines how many inputs passed into model_forward at a time.</p> <code>32</code>"},{"location":"#deeplocalizer.DeepLocalizer.compute_activations","title":"compute_activations","text":"<pre><code>compute_activations() -&gt; DeepLocalizer\n</code></pre> <p>Computes activations using the given provided <code>model_forward</code>. Must populate activations to use other core functions.</p>"},{"location":"#deeplocalizer.DeepLocalizer.load_activations","title":"load_activations","text":"<pre><code>load_activations(filename: str, device: torch.device = 'cpu') -&gt; DeepLocalizer\n</code></pre> <p>Loads activations into the DeepLocalizer from a file/disk. Must populate activations to use other core functions.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename of a .safetensors file where each dict key is an integer formatted a string</p> required <code>device</code> <code>torch.device</code> <p>where to load tensors into. Essentially passes into torch.tensor(..., device)</p> <code>'cpu'</code>"},{"location":"#deeplocalizer.DeepLocalizer.save_activations","title":"save_activations","text":"<pre><code>save_activations(filename: str)\n</code></pre> <p>Save activations from the DeepLocalizer to a file/disk. Can be loaded later on with <code>load_activations</code></p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>the filename to save the activations to disk</p> required"},{"location":"#deeplocalizer.DeepLocalizer.top_percent_activations","title":"top_percent_activations","text":"<pre><code>top_percent_activations(top_percent: float, transform=lambda x: torch.abs(x)) -&gt; tuple[list[int], list[int]]\n</code></pre>"},{"location":"#deeplocalizer.DeepLocalizer.regular_model_forward","title":"regular_model_forward","text":"<pre><code>regular_model_forward(df: pd.DataFrame = None) -&gt; tuple[ModelForwardReturn, ModelForwardReturn]\n</code></pre> <p>Runs the model on <code>positive=True</code> dataframe and <code>positive=False</code> instances w/ no ablation (original model).</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>the task data to run model on. Must have columns <code>data</code> and <code>positive</code> (bool). Defaults to the task provided in the constructor.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ModelForwardReturn, ModelForwardReturn]</code> <p>(Model outputs for <code>positive=True</code> rows, Model outputs for <code>positive=False</code> rows)</p>"},{"location":"#deeplocalizer.DeepLocalizer.ablate_model_forward","title":"ablate_model_forward","text":"<pre><code>ablate_model_forward(ablate_activations: list[AblateIdxs], df: pd.DataFrame = None) -&gt; tuple[ModelForwardReturn, ModelForwardReturn]\n</code></pre> <p>Runs the ablated model on <code>positive=True</code> dataframe and <code>positive=False</code> instances.</p> <p>Parameters:</p> Name Type Description Default <code>ablate_activations</code> <code>list[AblateIdxs]</code> <p>List where each row is a layer and each column is a flat index of the outputs to ablate.</p> required <code>df</code> <code>pd.DataFrame</code> <p>the task data to run model on. Must have columns <code>data</code> and <code>positive</code> (bool). Defaults to the task provided in the constructor.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ModelForwardReturn, ModelForwardReturn]</code> <p>(Model outputs for <code>positive=True</code> rows, Model outputs for <code>positive=False</code> rows)</p>"},{"location":"#visualization","title":"Visualization","text":""},{"location":"#deeplocalizer.visualize_activations","title":"visualize_activations","text":"<pre><code>visualize_activations(activations: list[torch.Tensor], grid=None, cmap='viridis')\n</code></pre> Source code in <code>deeplocalizer/deeplocalizer.py</code> <pre><code>def visualize_activations(activations: list[torch.Tensor], grid=None, cmap=\"viridis\"):\n    if grid is None:\n        # first combine all the layers so can do argpartition\n        for i, a in enumerate(activations):\n            plt.title(f\"Layer {i}\")\n            plt.imshow(squarify(a), cmap=cmap, aspect=\"auto\")\n            plt.colorbar()\n            plt.show()\n    else:\n        fig, axes = plt.subplots(*grid, figsize=(16, 9))\n        fig.suptitle(\"Absolute activations\")\n        for i, ax in enumerate(axes.flat):\n            a = activations[i]\n            im = ax.imshow(squarify(a), cmap=cmap, aspect=\"auto\")\n            ax.set_title(f\"Layer {i}\")\n            plt.colorbar(im, ax=ax)\n            no_ticks(ax)\n        plt.show()\n</code></pre>"},{"location":"#deeplocalizer.visualize_top_per_layer","title":"visualize_top_per_layer","text":"<pre><code>visualize_top_per_layer(top_idxs, activations, title='Percentage Top activations per layer')\n</code></pre> Source code in <code>deeplocalizer/deeplocalizer.py</code> <pre><code>def visualize_top_per_layer(\n    top_idxs, activations, title=\"Percentage Top activations per layer\"\n):\n    import seaborn as sns\n    import numpy as np\n\n    total_lengths = [prod(a.shape) for a in activations]\n    percentages = (\n        np.array([len(top_idxs[i]) / l for i, l in enumerate(total_lengths)]).reshape(\n            (-1, 1)\n        )\n        * 100\n    )\n    labels = np.array([f\"{p[0]:.2f}%\" for p in percentages]).reshape(percentages.shape)\n\n    plt.figure(figsize=(4, 6))\n    ax = sns.heatmap(\n        percentages,\n        cmap=\"inferno\",\n        annot=labels,\n        annot_kws={\"fontsize\": 10},\n        fmt=\"s\",\n        linecolor=\"white\",\n        linewidths=1,\n    )\n    ax.set(\n        title=title,\n        xticklabels=[],\n        xticks=[],\n        ylabel=\"Layers\",\n    )\n\n    plt.show()\n</code></pre>"},{"location":"#deeplocalizer.visualize_top_activations","title":"visualize_top_activations","text":"<pre><code>visualize_top_activations(top_idxs, top_values, activations, grid=(4, 4), title='Top % activations showing')\n</code></pre> Source code in <code>deeplocalizer/deeplocalizer.py</code> <pre><code>def visualize_top_activations(\n    top_idxs, top_values, activations, grid=(4, 4), title=\"Top % activations showing\"\n):\n    fig, axes = plt.subplots(*grid, figsize=(16, 9))\n    fig.suptitle(title)\n    for i, ax in enumerate(axes.flat):\n        a = activations[i]\n        top_idx = top_idxs[i]\n        top_value = top_values[i]\n        visualize_top_activation(ax, top_idx, top_value, a, title=f\"Layer {i}\")\n    plt.show()\n</code></pre>"},{"location":"#types","title":"Types","text":""},{"location":"#deeplocalizer.ModelForwardFunc","title":"ModelForwardFunc  <code>module-attribute</code>","text":"<pre><code>ModelForwardFunc = Callable[[list[Any]], ModelForwardReturn]\n</code></pre>"},{"location":"#deeplocalizer.ModelForwardReturn","title":"ModelForwardReturn  <code>module-attribute</code>","text":"<pre><code>ModelForwardReturn = Any | tuple\n</code></pre>"},{"location":"#deeplocalizer.SaveActivationsFunc","title":"SaveActivationsFunc  <code>module-attribute</code>","text":"<pre><code>SaveActivationsFunc = Callable[[torch.Tensor], torch.Tensor]\n</code></pre>"},{"location":"#deeplocalizer.AblateActivationsFunc","title":"AblateActivationsFunc  <code>module-attribute</code>","text":"<pre><code>AblateActivationsFunc = Callable[[torch.Tensor, AblateIdxs, float], torch.Tensor]\n</code></pre>"},{"location":"#deeplocalizer.AblateIdxs","title":"AblateIdxs  <code>module-attribute</code>","text":"<pre><code>AblateIdxs = torch.Tensor | list[int]\n</code></pre>"}]}